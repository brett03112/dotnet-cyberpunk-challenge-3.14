using dotnet_cyberpunk_challenge_3_14.malware.lib._lib;
using dotnet_cyberpunk_challenge_3_14.malware.lib._lib.interfaces;

namespace dotnet_cyberpunk_challenge_3_14.malware.lib
{
    public abstract class MultiKuangDaemonFamilyBase<T, Z> 
        where T : MessageRoot
        where Z : ProcessList
    {
        protected bool IsConnectionTunnelProtected {get;set;}
        protected bool IsConnectionProxyEnabled {get;set;}
        public ServerConnection<T> CurrentServerConnection {get;set;}
        public IceBreakerTunnelConnection<T> CurrentIceBreakerTunnelConnection {get;set;}



        public abstract Task SetupIceBreakerTunnelToTarget(); // Setup the connection tunnel between host and target

        public abstract Task<string> GetIceTypeOnRemote(); // Students need to Get type of ICE on target

        public abstract void IceBreak(); // Students need to Attempt to Break the ICE

        public abstract Task Initialize();
        
        public abstract Task<List<Z>> GetProcessList();

        // FIXME: Mentor note - This be cool spot to teach them about why protected method abstraction is cool

        public abstract Task<IEnumerable<string?>> GetProcessMemoryMapping(); 



        /// <summary>
        /// Gets the current connection to the target server. If a connection doesn't exist, one will be created
        /// </summary>
        /// <returns>A <see cref="ServerConnection{T}"/> to the target server</returns>
        /// <exception cref="Exception">If the target server cannot be connected to</exception>
        public async virtual Task<ServerConnection<T>> GetCurrentConnection() 
        {
            try {
                if (CurrentServerConnection != null) {
                    return CurrentServerConnection;
                } else {
                    throw new Exception("Not Currently connected to an Arasaka Server! Hope your synapses aren't burnt out.");
                }
            } catch {
                CurrentServerConnection = _EstablishConnectionToTargetServer();
                await CurrentServerConnection.Initialize();
                return CurrentServerConnection;
            }
        }

        /// <summary>
        /// Check if the ICE type from the target server is HITACHI
        /// </summary>
        /// <param name="retrievedModelType">The string from the target server identifying the type of ICE installed</param>
        /// <returns>true if the ICE type is HITACHI, false otherwise</returns>
        protected virtual bool _IsTargetHatichiICE(string retrievedModelType){
            return KnownIceTypes.HITACHI == retrievedModelType;
        }

        /// <summary>
        /// Check if the ICE type from the target server is HOSAKA
        /// </summary>
        /// <param name="retrievedModelType">The string from the target server identifying the type of ICE installed</param>
        /// <returns>true if the ICE type is HOSAKA, false otherwise</returns>
        protected virtual bool _IsTargetHosakaICE(string retrievedModelType){
            return KnownIceTypes.HOSAKA == retrievedModelType;
        }

        /// <summary>
        /// Check if the ICE type from the target server is KIROSHI
        /// </summary>
        /// <param name="retrievedModelType">The string from the target server identifying the type of ICE installed</param>
        /// <returns>true if the ICE type is KIROSHI, false otherwise</returns>
        protected virtual bool _IsTargetKiroshiICE(string retrievedModelType){
            return KnownIceTypes.KIROSHI == retrievedModelType;
        }

        /// <summary>
        /// Establishes a connection to the target server. This is a virtual method and can be overridden
        /// by derived classes to provide a different type of server connection.
        /// </summary>
        /// <returns>A <see cref="ServerConnection{T}"/> to the target server</returns>
        protected virtual ServerConnection<T> _EstablishConnectionToTargetServer() {
            // return new ArasakaServerConnection();
            return new ServerConnection<T>();
        }


        /// <summary>
        /// Encrypts the connection to the target server. This is used to protect the malware
        /// from ICE and other network security measures. This method is virtual and can
        /// be overridden by derived classes to customize the encryption process.
        /// </summary>
        /// <param name="tunnel">The current <see cref="IceBreakerTunnelConnection{T}"/> to the target server</param>
        /// <returns>A new <see cref="IceBreakerTunnelConnection{T}"/> that is encrypted</returns>
        protected async virtual Task<IceBreakerTunnelConnection<T>> _EncryptConnection(IceBreakerTunnelConnection<T> tunnel) {
            // Initialize the tunnel connection to the target server
            await tunnel.Initialize();

            // Check if the tunnel connection is encrypted and the encryption type is SSL
            IsConnectionTunnelProtected = tunnel.IsEncrypted == true && tunnel.TunnelEncryption == EncryptionType.SSL;

            // Enable the connection proxy if the tunnel connection is encrypted
            IsConnectionProxyEnabled = tunnel.IsEncrypted;

            // Return the encrypted tunnel connection
            return tunnel;
        }
    }
}