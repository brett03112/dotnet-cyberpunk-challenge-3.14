using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;

namespace dotnet_cyberpunk_challenge_3_14.malware.lib._lib
{
    public class ServerConnection<T> where T : MessageRoot
    {
        public string ConnectionId {get;set;}
        public string DestinationAddress {get;set;}
        public string SourceAddress {get;set;}
        public string ProcessId {get;set;}
        public string Content {get;set;}
        public string SecretKey {get;set;}
        private string DefaultDNSTarget = "8.8.8.8"; // Google

        /// <summary>
        /// A class representing a connection to an ICE server.
        /// </summary>
        /// <remarks>
        /// This class is a base class for all server connections. It provides a default
        /// implementation of the <see cref="Initialize"/> method, which will get the
        /// destination address of the server, get the IP address of the current machine,
        /// get a secret key for the server, send a request to establish a connection to
        /// the server, generate a new connection ID, generate a new process ID, and set
        /// the <see cref="Content"/> property to an empty string.
        /// </remarks>
        public ServerConnection() {
            
        }

        /// <summary>
        /// Initializes the connection to the server. This involves:
        /// 1. Getting the destination address of the server.
        /// 2. Getting the IP address of the current machine.
        /// 3. Getting a secret key for the server.
        /// 4. Sending a request to establish a connection to the server.
        /// 5. Generating a new connection ID.
        /// 6. Generating a new process ID.
        /// </summary>
        public async virtual Task Initialize() {
            DestinationAddress = _GetDestinationAddress();
            SourceAddress = _GetCurrentSourceIpAddress();
            SecretKey = _GetSecretKey();

            await SendRequest("establish-connection");
            ConnectionId = Guid.NewGuid().ToString();
            ProcessId = _GetNewProcessId();
            Content = "";
        }

        /// <summary>
        /// Sends a request to the server and returns the parsed response.
        /// This method will:
        /// 1. Generate the full path of the request by prepending the server type
        ///    to the provided path.
        /// 2. Call the <see cref="_SendRequest"/> method with the generated path.
        /// 3. Return the parsed response from the server.
        /// </summary>
        /// <param name="uriPath">The path to send the request to. This should not include the server type.</param>
        /// <returns>A parsed response from the server.</returns>
        public async Task<T> SendRequest(string uriPath) {
            string fullMessagePath = "";
            if (typeof(T) == typeof(ArasakaMessageRoot)) {
                fullMessagePath = $"arasaka/{uriPath}";
            } 
            else if (typeof(T) == typeof(MilitechMessageRoot)) {
                fullMessagePath = $"militech/{uriPath}";
            } 
            else if (typeof(T) == typeof(BiotechnicaMessageRoot)) {
                fullMessagePath = $"biotechnica/{uriPath}";
            } 
            else {
                throw new NotImplementedException();
            }
            return await _SendRequest(fullMessagePath);
        }

        /// <summary>
        /// Gets the destination address of the server. This will first check the environment variable
        /// ICE_DESTINATION_SERVER and use that if it exists, otherwise it will use a default value.
        /// </summary>
        /// <returns>The destination address of the server.</returns>
        protected string _GetDestinationAddress() {
            string defaultDestination = "https://my.api.mockaroo.com";
            string destinationEnvvar = Environment.GetEnvironmentVariable("ICE_DESTINATION_SERVER");

            if (destinationEnvvar != null && destinationEnvvar != ""){
                return destinationEnvvar;
            } else {
                return defaultDestination;
            }
        }

        /// <summary>
        /// Sends a request to the server and returns the parsed response.
        /// This method will:
        /// 1. Create a new instance of <see cref="HttpClient"/> with the destination address.
        /// 2. Clear the default request headers and add the user agent and API key.
        /// 3. Send a GET request to the specified path.
        /// 4. Ensure the response was successful.
        /// 5. Write the request to the console.
        /// 6. Read the response as a string.
        /// 7. Parse the response as a message of type T.
        /// 8. Return the parsed response.
        /// </summary>
        /// <param name="uriPath">The path to send the request to.</param>
        /// <returns>A parsed response from the server.</returns>
        protected async Task<T> _SendRequest(string uriPath){
            HttpClient client = new HttpClient() {
                BaseAddress = new Uri(DestinationAddress),
                Timeout = TimeSpan.FromSeconds(20)
            };
            
            client.DefaultRequestHeaders.Accept.Clear();
            client.DefaultRequestHeaders.Add("User-Agent", "Kuang Grade Eleven ICE Breaker");
            client.DefaultRequestHeaders.Add("X-API-Key", SecretKey);

            using HttpResponseMessage response = await client.GetAsync(uriPath);

            response.EnsureSuccessStatusCode()
                .WriteRequestToConsole();
            
            var jsonResponse = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"{jsonResponse}\n");

            if (typeof(T) == typeof(ArasakaMessageRoot)) {
                return (T)Convert.ChangeType(jsonResponse.ToArasakaMessage(), typeof(T));
            } 
            
            else if (typeof(T) == typeof(MilitechMessageRoot)) {
                return (T)Convert.ChangeType(jsonResponse.ToMilitechMessage(), typeof(T));
            } 
            
            else if (typeof(T) == typeof(BiotechnicaMessageRoot)) {
                return (T)Convert.ChangeType(jsonResponse.ToBiotechnicaMessage(), typeof(T));
            }
            
            else {
                throw new NotImplementedException("We haven't implemented that type of message yet!");
            }  
        }
    
        protected string _GetSecretKey() {
            if (Environment.GetEnvironmentVariable("ARASAKA_SECRET_KEY") == null || Environment.GetEnvironmentVariable("ARASAKA_SECRET_KEY") == ""){
                // FIXME: TECH DEBT - This IS NOT the right way to do it but is 
                // too much effort at the minute to do it the right way
                // :)
                return "cf7bbbd0";
            } 
            else 
            {
                return Environment.GetEnvironmentVariable("ARASAKA_SECRET_KEY");
            }
        }

        /// <summary>
        /// Write the secret key to file. This is a protected method that must be
        /// implemented by any derived classes and is used by the <see cref="Initialize"/> method
        /// to persist the secret key to file.
        /// </summary>
        /// <remarks>
        /// This method is not implemented in this base class and must be implemented by any derived
        /// classes.
        /// </remarks>
        protected void _WriteSecretKeyToFile() {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets the source IP address of the machine running this application.
        /// </summary>
        /// <returns>The source IP address of the machine running this application.</returns>
        /// <remarks>
        /// This method is used to get the IP address of the machine running this application.
        /// It does this by creating a UDP socket and connecting to the DefaultDNSTarget, which
        /// is a fixed IP address. It then gets the local endpoint of the socket and returns
        /// the IP address associated with it.
        /// </remarks>
        protected string _GetCurrentSourceIpAddress() {
            string localIP;
            using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, 0))
            {
                socket.Connect(DefaultDNSTarget, 65530);
                IPEndPoint endPoint = socket.LocalEndPoint as IPEndPoint;
                localIP = endPoint.Address.ToString();
            }

            return localIP;
        }

        /// <summary>
        /// Gets a new process ID. This is a random number between 0 and 20000.
        /// </summary>
        /// <returns>A string representing the new process ID.</returns>
        protected string _GetNewProcessId() {
            return new Random().Next(0,20000).ToString();
        }
    }

    public class IceBreakerTunnelConnection<T> : ServerConnection<T>
        where T : MessageRoot
    {
        public EncryptionType TunnelEncryption {get;set;}
        public bool IsEncrypted {get;set;}

        /// <summary>
        /// Initializes the ICE breaker tunnel connection to the server. This involves:
        /// 1. Getting the destination address of the server.
        /// 2. Getting the IP address of the current machine.
        /// 3. Getting a secret key for the server.
        /// 4. Sending a request to establish a connection to the server.
        /// 5. Generating a new connection ID.
        /// 6. Generating a new process ID.
        /// </summary>
        /// <remarks>
        /// This method will also set the <see cref="IsEncrypted"/> and <see cref="TunnelEncryption"/>
        /// properties to true and SSL respectively.
        /// </remarks>
        public override async Task Initialize() {
            DestinationAddress = _GetDestinationAddress();
            SourceAddress = _GetCurrentSourceIpAddress();
            SecretKey = _GetSecretKey();

            await SendRequest("establish-connection");
            ConnectionId = Guid.NewGuid().ToString();
            ProcessId = _GetNewProcessId();
            Content = "";

            IsEncrypted = true;
            TunnelEncryption = EncryptionType.SSL;

        }
    }
}