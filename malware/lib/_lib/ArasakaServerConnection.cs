using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using dotnet_cyberpunk_challenge_3_14.malware.lib._lib.interfaces;


/*
    NOTE: This file has been deprecated and is only here for reference!
    DO NOT CHANGE!
*/
namespace dotnet_cyberpunk_challenge_3_14.malware.lib._lib
{
    public class ArasakaServerConnection
    {
        public string ConnectionId {get;set;}
        public string DestinationAddress {get;set;}
        public string SourceAddress {get;set;}
        public string ProcessId {get;set;}
        public string Content {get;set;}
        public string SecretKey {get;set;}
        private string DefaultDNSTarget = "8.8.8.8"; // Google

        /// <summary>
        /// Empty constructor for ArasakaServerConnection. Will throw NotImplementedException on use.
        /// </summary>
        public ArasakaServerConnection() {
            _MakeSureWeCantUseThis();
        }

        /// <summary>
        /// If this constructor is used, it will throw a NotImplementedException because
        /// ArasakaServerConnection is not meant to be used directly. Instead, a new
        /// class should be created that inherits from ArasakaServerConnection and
        /// implements the abstract methods.
        /// </summary>
        protected virtual void _MakeSureWeCantUseThis() {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Establish a connection to the Arasaka server. This involves:
        /// 1. Getting the destination address of the Arasaka server
        /// 2. Getting the IP address of the current machine
        /// 3. Getting an Arasaka secret key
        /// 4. Sending a request to establish a connection to the Arasaka server
        /// 5. Generating a new connection ID
        /// 6. Generating a new process ID
        /// </summary>
        public async virtual Task Initialize() {
            DestinationAddress = _GetDestinationAddress();
            SourceAddress = _GetCurrentSourceIpAddress();
            SecretKey = _GetArasakaSecretKey();

            await SendRequest("establish-connection");
            ConnectionId = Guid.NewGuid().ToString();
            ProcessId = _GetNewProcessId();
            Content = "";
        }

        /// <summary>
        /// Sends a request to the Arasaka server and returns the parsed response.
        /// </summary>
        /// <param name="uriPath">The path to send the request to. This should not include the domain name.</param>
        /// <returns>A parsed response from the Arasaka server.</returns>
        public async Task<ArasakaMessageRoot> SendRequest(string uriPath) {
            return await _SendRequest(uriPath);
        }

        /// <summary>
        /// Gets the destination address for the Arasaka server.
        /// This will first check the environment variable ARASAKA_DESTINATION_SERVER
        /// and use that if it exists, otherwise it will use a default value.
        /// </summary>
        protected string _GetDestinationAddress() {
            string defaultArasakaDestination = "https://my.api.mockaroo.com";
            string arasaka_destination_envvar = Environment.GetEnvironmentVariable("ARASAKA_DESTINATION_SERVER");
            
            if (arasaka_destination_envvar != null && arasaka_destination_envvar != ""){
                return arasaka_destination_envvar;
            } else {
                return defaultArasakaDestination;
            }
        }

        /// <summary>
        /// Sends a request to the Arasaka server and returns the parsed response.
        /// This method will:
        /// 1. Create a new instance of <see cref="HttpClient"/> with the destination address.
        /// 2. Clear the default request headers and add the user agent and API key.
        /// 3. Send a GET request to the specified path.
        /// 4. Ensure the response was successful.
        /// 5. Write the request to the console.
        /// 6. Read the response as a string.
        /// 7. Parse the response as an <see cref="ArasakaMessageRoot"/>.
        /// 8. Return the parsed response.
        /// </summary>
        /// <returns>A parsed response from the Arasaka server.</returns>
        protected async Task<ArasakaMessageRoot> _SendRequest(string uriPath){
            HttpClient client = new HttpClient() {
                BaseAddress = new Uri(DestinationAddress),
                Timeout = TimeSpan.FromSeconds(20)
            };
            
            client.DefaultRequestHeaders.Accept.Clear();
            client.DefaultRequestHeaders.Add("User-Agent", "Arasaka ICE Breaker");
            client.DefaultRequestHeaders.Add("X-API-Key", SecretKey);

            using HttpResponseMessage response = await client.GetAsync($"arasaka/{uriPath}");

            response.EnsureSuccessStatusCode()
                .WriteRequestToConsole();
            
            var jsonResponse = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"{jsonResponse}\n");

            ArasakaMessageRoot parsedArasakaResponse = jsonResponse.ToArasakaMessage();
            
            return parsedArasakaResponse;
        }
    
        /// <summary>
        /// Gets the secret key for the Arasaka server. This will first check the environment variable
        /// ARASAKA_SECRET_KEY and use that if it exists, otherwise it will use a default value.
        /// </summary>
        /// <returns>The secret key for the Arasaka server.</returns>
        protected string _GetArasakaSecretKey() {
            if (Environment.GetEnvironmentVariable("ARASAKA_SECRET_KEY") == null || Environment.GetEnvironmentVariable("ARASAKA_SECRET_KEY") == ""){
                // FIXME: TECH DEBT - This IS NOT the right way to do it but is 
                // too much effort at the minute to do it the right way
                // :)
                return "cf7bbbd0";
            } 
            else 
            {
                return Environment.GetEnvironmentVariable("ARASAKA_SECRET_KEY");
            }
        }

        /// <summary>
        /// Write the secret key for the Arasaka server to file. This is a protected method that must be
        /// implemented by any derived classes and is used by the <see cref="Initialize"/> method to
        /// persist the secret key to file.
        /// </summary>
        /// <remarks>
        /// This method is not implemented in this base class and must be implemented by any derived
        /// classes.
        /// </remarks>
        protected void _WriteArasakaSecretKeyToFile() {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets the source IP address of the machine running this application.
        /// </summary>
        /// <returns>The source IP address of the machine running this application.</returns>
        /// <remarks>
        /// This method is used to get the IP address of the machine running this application.
        /// It does this by creating a UDP socket and connecting to the DefaultDNSTarget, which
        /// is a fixed IP address. It then gets the local endpoint of the socket and returns
        /// the IP address associated with it.
        /// </remarks>
        protected string _GetCurrentSourceIpAddress() {
            string localIP;
            using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, 0))
            {
                socket.Connect(DefaultDNSTarget, 65530);
                IPEndPoint endPoint = socket.LocalEndPoint as IPEndPoint;
                localIP = endPoint.Address.ToString();
            }

            return localIP;
        }

        /// <summary>
        /// Gets a new process ID. This is a random number between 0 and 20000.
        /// </summary>
        /// <returns>A string representing the new process ID.</returns>
        protected string _GetNewProcessId() {
            return new Random().Next(0,20000).ToString();
        }
    }

    public class IceBreakerArasakaTunnelConnection : ArasakaServerConnection, ITunnelConnection
    {
        public EncryptionType TunnelEncryption {get;set;}
        public bool IsEncrypted {get;set;}

        /// <summary>
        /// Initializes the ICE breaker tunnel connection to the Arasaka server. This involves:
        /// 1. Getting the destination address of the Arasaka server.
        /// 2. Getting the IP address of the current machine.
        /// 3. Getting an Arasaka secret key.
        /// 4. Sending a request to establish a connection to the Arasaka server.
        /// 5. Generating a new connection ID.
        /// 6. Generating a new process ID.
        /// </summary>
        /// <remarks>
        /// This method will also set the <see cref="IsEncrypted"/> and <see cref="TunnelEncryption"/>
        /// properties to true and SSL respectively.
        /// </remarks>
        public override async Task Initialize() {
            DestinationAddress = _GetDestinationAddress();
            SourceAddress = _GetCurrentSourceIpAddress();
            SecretKey = _GetArasakaSecretKey();

            await SendRequest("establish-connection");
            ConnectionId = Guid.NewGuid().ToString();
            ProcessId = _GetNewProcessId();
            Content = "";

            IsEncrypted = true;
            TunnelEncryption = EncryptionType.SSL;

        }
    }
}