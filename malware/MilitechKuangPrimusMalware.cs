using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_3_14.malware.lib;
using dotnet_cyberpunk_challenge_3_14.malware.lib._lib;

namespace dotnet_cyberpunk_challenge_3_14.malware
{
    public class MilitechKuangPrimusMalware : MultiKuangDaemonFamilyBase<MilitechMessageRoot, MilitechICEProcessList> {
        
        /// <summary>
        /// Initializes the ICE breaker by getting a connection to the target server.
        /// </summary>
        /// <remarks>
        /// This method sets up the ICE breaker by getting a connection to the target server.
        /// </remarks>
        public async override Task Initialize()
        {
            await GetCurrentConnection();
        }

        /// <summary>
        /// Gets the ICE type of the target server.
        /// </summary>
        /// <returns>A string indicating the type of ICE installed on the target server.</returns>
        /// <remarks>
        /// This method sends a "model-type" request to the target server and then checks the response
        /// to see if it matches the type of ICE we're looking for. If it does, it returns a string indicating
        /// the type of ICE. If it doesn't, it returns "unknown".
        /// </remarks>
        public async override Task<string> GetIceTypeOnRemote()
        {
            MilitechMessageRoot militechMessageResponse = await CurrentServerConnection.SendRequest("model-type");
            string modelType = militechMessageResponse.connection?.model!;

            string matchedModel = "";
            if (_IsTargetHatichiICE(modelType)){
                matchedModel = "hatachi";
            } else if (_IsTargetHosakaICE(modelType)) {
                matchedModel ="hosaka";
            } else if (_IsTargetKiroshiICE(modelType)) {
                matchedModel = "kiroshi";
            } else {
                matchedModel = "unknown";
            }

            return matchedModel; 
        }

        /// <summary>
        /// Gets the list of processes running on the target server.
        /// </summary>
        /// <returns>A list of <see cref="MilitechICEProcessList"/> objects, each one representing a process running on the target server.
        /// If there are no processes running, an empty list is returned.</returns>
        /// <remarks>
        /// This method sends a "process-list" request to the target server and then parses the response
        /// to get the list of processes running. If the response does not contain a list of processes,
        /// an empty list is returned.
        /// </remarks>
        public async override Task<List<MilitechICEProcessList>> GetProcessList()
        {
            MilitechMessageRoot message = await CurrentServerConnection.SendRequest("process-list");
            List<MilitechICEProcessList> processList = message.connection?.processList!;
            return processList!;
        }

        public async override void IceBreak()
        {
            throw new NotImplementedException();
        }

        // FIXME: DON'T CHANGE - This is still under development
        public async override Task SetupIceBreakerTunnelToTarget()
        {
            // CurrentIceBreakerMilitechTunnelConnection = new IceBreakerMilitechTunnelConnection();
            // await CurrentIceBreakerMilitechTunnelConnection.Initialize();
        }


        /// <summary>
        /// Gets the list of memory addresses associated with each process running on the target server.
        /// </summary>
        /// <returns>A list of strings, each one representing the memory address associated with a process running on the target server.
        /// If there are no processes running, an empty list is returned.</returns>
        /// <remarks>
        /// This method uses the <see cref="GetProcessList"/> method to get the list of processes running
        /// on the target server and then parses the response to get the list of memory addresses.
        /// </remarks>
        public async override Task<IEnumerable<string>> GetProcessMemoryMapping()
        {
            List<MilitechICEProcessList> militechMessageProcessLists = await GetProcessList();
            return militechMessageProcessLists?.Select(pl => pl.memoryStartingAddress)!;
        }
    }
}