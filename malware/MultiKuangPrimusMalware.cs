using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_3_14.malware.lib;
using dotnet_cyberpunk_challenge_3_14.malware.lib._lib;

namespace dotnet_cyberpunk_challenge_3_14.malware
{
    public class MultiKuangPrimusMalware<T, Z> : MultiKuangDaemonFamilyBase<T, Z>
        where T : MessageRoot
        where Z : ProcessList
    {
        /// <summary>
        /// Gets the ICE type of the target server.
        /// </summary>
        /// <returns>A string indicating the type of ICE installed on the target server.</returns>
        /// <remarks>
        /// This method sends a "model-type" request to the target server and then checks the response
        /// to see if it matches the type of ICE we're looking for. If it does, it returns a string indicating
        /// the type of ICE. If it doesn't, it returns "unknown".
        /// </remarks>
        public async override Task<string> GetIceTypeOnRemote()
        {
            T messageResponse = await CurrentServerConnection.SendRequest("model-type");
            string modelType = "";
            
            if (typeof(T) == typeof(MilitechMessageRoot)) {
                modelType = (messageResponse as MilitechMessageRoot).connection.model;
            } 
            else if (typeof(T) == typeof(ArasakaMessageRoot)) {
                modelType = (messageResponse as ArasakaMessageRoot).content.model;
            } 
            else if (typeof(T) == typeof(BiotechnicaMessageRoot)) {
                modelType = (messageResponse as BiotechnicaMessageRoot).connection.model;
            }
            else {
                throw new NotImplementedException();
            }

            string matchedModel = "";
            if (_IsTargetHatichiICE(modelType)){
                matchedModel = "hatachi";
            } else if (_IsTargetHosakaICE(modelType)) {
                matchedModel ="hosaka";
            } else if (_IsTargetKiroshiICE(modelType)) {
                matchedModel = "kiroshi";
            } else {
                matchedModel = "unknown";
            }

            return matchedModel; 
        }

        /// <summary>
        /// Gets the list of memory addresses associated with each process running on the target server.
        /// </summary>
        /// <returns>A list of strings, each one representing the memory address associated with a process running on the target server.
        /// If there are no processes running, an empty list is returned.</returns>
        public async override Task<IEnumerable<string>> GetProcessMemoryMapping()
        {
            List<Z> messageProcessLists = await GetProcessList();
            return messageProcessLists?.Select(pl => pl.memoryStartingAddress) ?? Enumerable.Empty<string>();
        }

        /// <summary>
        /// Gets the list of processes running on the target server.
        /// </summary>
        /// <returns>A list of <see cref="Z"/> objects, each one representing a process running on the target server.
        /// If there are no processes running, an empty list is returned.</returns>
        /// <remarks>
        /// This method sends a "process-list" request to the target server and then parses the response
        /// to get the list of processes running. If the response does not contain a list of processes,
        /// an empty list is returned.
        /// </remarks>
        public async override Task<List<Z>> GetProcessList() {
            T message = await CurrentServerConnection.SendRequest("process-list");
            List<Z> processList = null;

            if (typeof(Z) == typeof(MilitechICEProcessList)) {
                processList = (message as MilitechMessageRoot)?.connection?.processList as List<Z>;
            
            } else if (typeof(Z) == typeof(ArasakaMessageProcessList)) {
                processList = (message as ArasakaMessageRoot)?.content?.processList as List<Z>;

            } else if (typeof (Z) == typeof(BiotechnicaICEProcessList)) {
                processList = (message as BiotechnicaMessageRoot)?.connection?.processList as List<Z>;
            
            } else{
                throw new NotImplementedException();
            }

            return processList ?? new List<Z>();
        }

        /// <summary>
        /// Starts the ICE breaking process.
        /// </summary>
        /// <remarks>
        /// This method starts the ICE breaking process, which involves sending a series of requests to the target server
        /// in order to disable its ICE protection. The method does not return until the ICE has been broken.
        /// </remarks>
        /// <exception cref="NotImplementedException">This method is not implemented yet.</exception>
        public override void IceBreak()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Initializes this instance of the ICE breaker.
        /// </summary>
        /// <remarks>
        /// This method sets up the ICE breaker by getting a connection to the target server.
        /// </remarks>
        public async override Task Initialize()
        {
            await GetCurrentConnection();
        }

        /// <summary>
        /// Sets up the ICE breaker tunnel to the target server.
        /// </summary>
        /// <remarks>
        /// This method sets up the ICE breaker tunnel by creating an instance of <see cref="IceBreakerTunnelConnection{T}"/>
        /// and then initializing it. The tunnel is used to send requests to the target server that break its ICE protection.
        /// </remarks>
        public async override Task SetupIceBreakerTunnelToTarget()
        {
            CurrentIceBreakerTunnelConnection = new IceBreakerTunnelConnection<T>();
            await CurrentIceBreakerTunnelConnection.Initialize();
        }
    }
}