using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_3_14.malware.lib;
using dotnet_cyberpunk_challenge_3_14.malware.lib._lib;


namespace dotnet_cyberpunk_challenge_3_14.malware
{
    public class ArasakaKuangPrimusMalware : MultiKuangDaemonFamilyBase<ArasakaMessageRoot, ArasakaMessageProcessList> {
        /// <summary>
        /// Initializes the ICE breaker by getting a connection to the target server.
        /// </summary>
        /// <remarks>
        /// This method sets up the ICE breaker by getting a connection to the target server.
        /// </remarks>
        public async override Task Initialize()
        {
            await GetCurrentConnection();
        }
    
        /// <summary>
        /// Gets the ICE type of the target server.
        /// </summary>
        /// <returns>A string indicating the type of ICE installed on the target server.</returns>
        /// <remarks>
        /// This method sends a "model-type" request to the target server and then checks the response
        /// to see if it matches the type of ICE we're looking for. If it does, it returns a string indicating
        /// the type of ICE. If it doesn't, it returns "unknown".
        /// </remarks>
        public async override Task<string> GetIceTypeOnRemote()
        {
            ArasakaMessageRoot arasakaMessageResponse = await CurrentServerConnection.SendRequest("model-type");
            string modelType = arasakaMessageResponse.content?.model!;

            string matchedModel = "";
            if (_IsTargetHatichiICE(modelType!)){
                matchedModel = "hatachi";
            } else if (_IsTargetHosakaICE(modelType!)) {
                matchedModel ="hosaka";
            } else if (_IsTargetKiroshiICE(modelType!)) {
                matchedModel = "kiroshi";
            } else {
                matchedModel = "unknown";
            }

            return matchedModel; 
        }

        /// <summary>
        /// Gets the list of processes running on the target server.
        /// </summary>
        /// <returns>A list of <see cref="ArasakaMessageProcessList"/> objects, each one representing a process running on the target server.
        /// If there are no processes running, an empty list is returned.</returns>
        /// <remarks>
        /// This method sends a "process-list" request to the target server and then parses the response
        /// to get the list of processes running. If the response does not contain a list of processes,
        /// an empty list is returned.
        /// </remarks>
        public async override Task<List<ArasakaMessageProcessList>> GetProcessList()
        {
            ArasakaMessageRoot message = await CurrentServerConnection.SendRequest("process-list");
            List<ArasakaMessageProcessList> processList = message.content?.processList!;
            return processList;
        }


        public async override void IceBreak()
        {
            throw new NotImplementedException();
        }


        // FIXME: DON'T CHANGE - This is still under development
        public async override Task SetupIceBreakerTunnelToTarget()
        {
            // CurrentIceBreakerTunnelConnection  = new CurrentIceBreakerTunnelConnection();
            // await CurrentIceBreakerTunnelConnection .Initialize();
        }

        /// <summary>
        /// Gets the list of memory addresses associated with each process running on the target server.
        /// </summary>
        /// <returns>A list of strings, each one representing the memory address associated with a process running on the target server.
        /// If there are no processes running, an empty list is returned.</returns>
        /// <remarks>
        /// This method uses the <see cref="GetProcessList"/> method to get the list of processes running
        /// on the target server and then parses the response to get the list of memory addresses.
        /// </remarks>
        public async override Task<IEnumerable<string>> GetProcessMemoryMapping()
        {
            List<ArasakaMessageProcessList> arasakaMessageProcessLists = await GetProcessList();
            return arasakaMessageProcessLists.Select(pl => pl.memoryStartingAddress);
        }
    }
}